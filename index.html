<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Agenda Online Beleza Multi-Dias - SIMULAÇÃO DE BACKEND</title>
    
    <link rel="stylesheet" href="style.css"> 
    
    <script src="https://unpkg.com/react@18/umd/react.development.js" crossorigin></script>
    <script src="https://unpkg.com/react-dom@18/umd/react-dom.development.js" crossorigin></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
</head>
<body>
    <div id="root"></div>

    <script type="text/babel">
        
        // ====================================================================
        // CONSTANTES E FUNÇÕES DE UTILITY
        // ====================================================================
        const HORARIOS = [
            "09:00", "10:00", "11:00", "12:00",
            "14:00", "15:00", "16:00", "17:00", "18:00"
        ];
        const SERVICOS = [
            { nome: "Cabelo", duracao: 60 },
            { nome: "Manicure", duracao: 45 },
            { nome: "Pedicure", duracao: 45 },
            { nome: "Lash Design", duracao: 90 }
        ];

        // ⚠️ SIMULAÇÃO DE UM ENDPOINT DE BACKEND (JSONPlaceholder é um mock)
        // Em um projeto real, esta URL seria seu servidor (Firebase, Sheet API, etc.)
        const API_BASE_URL = 'https://jsonplaceholder.typicode.com/posts'; // Endpoint de teste
        
        // UTILITY: Formata a data para a chave de armazenamento (YYYY-MM-DD)
        const formatDate = (date) => {
            return date.toISOString().split('T')[0];
        };

        // UTILITY: Gera a lista de datas da semana (ignorando segunda-feira)
        const getNextWeekDays = () => {
            const dates = [];
            const today = new Date();
            
            for (let i = 0; i < 7; i++) {
                const day = new Date(today);
                day.setDate(today.getDate() + i);
                
                const dayOfWeek = day.getDay();
                
                // Ignora segunda-feira (1)
                if (dayOfWeek !== 1) {
                    dates.push({
                        value: formatDate(day),
                        label: day.toLocaleDateString('pt-BR', { weekday: 'short', month: 'numeric', day: 'numeric' })
                    });
                }
            }
            return dates;
        };

        const DIAS_DISPONIVEIS = getNextWeekDays();
        
        // UTILITY: Define a data inicial (o primeiro dia disponível)
        const DATA_INICIAL = DIAS_DISPONIVEIS[0].value;


        // ⭐️ FUNÇÃO DE PERSISTÊNCIA: Carregar dados do "servidor"
        const fetchAgendamentos = async (setDataCallback) => {
            // Em um APP real, você buscaria os dados por dia ou todos de uma vez.
            // Aqui, simulamos que o servidor retorna uma lista base com um agendamento.
            console.log("SIMULANDO: Buscando agendamentos do servidor...");
            
            // Dados de teste para simular o que viria do servidor:
            const defaultDate = DIAS_DISPONIVEIS[0].value;
            const dataSimuladaDoServidor = {
                [defaultDate]: [
                    { 
                        id: `server-test-${defaultDate}`, 
                        horario: "11:00", 
                        nome: "Cliente Servidor (Simulação)", 
                        servico: "Cabelo", 
                        telefone: "1111-2222", 
                        data: defaultDate 
                    },
                ],
            };

            // ⚠️ Neste mock, retornamos apenas o dado simulado. 
            // Você substituiria este bloco pela chamada 'fetch' real:
            // try {
            //     const response = await fetch(API_BASE_URL);
            //     const data = await response.json();
            //     setDataCallback(data); // Assume que 'data' tem o formato correto: { "YYYY-MM-DD": [...] }
            // } catch (error) {
            //     console.error("Erro ao buscar dados reais:", error);
            //     setDataCallback(dataSimuladaDoServidor);
            // }

            setDataCallback(dataSimuladaDoServidor); 
            console.log("SIMULANDO: Agendamentos carregados. (Esses dados não persistem no mock API)");
        };

        // ⭐️ FUNÇÃO DE PERSISTÊNCIA: Enviar dados para o "servidor"
        const sendAgendamentoToServer = async (novoAgendamento) => {
            console.log("SIMULANDO: Enviando novo agendamento para o servidor...");

            // Em um APP real, você faria um POST para o seu servidor
            /* try {
                const response = await fetch(API_BASE_URL, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify(novoAgendamento),
                });
                
                if (!response.ok) {
                    throw new Error(`Erro do servidor: ${response.status}`);
                }
                const data = await response.json();
                console.log("Agendamento salvo com sucesso no servidor:", data);
                return data; 
            } catch (error) {
                console.error("Erro ao salvar agendamento no servidor:", error);
                alert("Erro ao salvar agendamento! Consulte o console.");
                return null;
            }
            */
            
            // Retorna o próprio objeto para simular sucesso
            console.log("SIMULANDO: Servidor aceitou o agendamento.");
            return novoAgendamento; 
        };
        
        // ⭐️ FUNÇÃO DE PERSISTÊNCIA: Deletar agendamento no "servidor"
        const deleteAgendamentoFromServer = async (agendamentoId) => {
            console.log(`SIMULANDO: Tentando deletar agendamento ID: ${agendamentoId} no servidor...`);
            
            // Em um APP real, você faria um DELETE para o seu servidor
            /*
            try {
                const response = await fetch(`${API_BASE_URL}/${agendamentoId}`, {
                    method: 'DELETE',
                });
                if (!response.ok) {
                    throw new Error(`Erro do servidor ao deletar: ${response.status}`);
                }
                console.log("Agendamento deletado com sucesso no servidor.");
                return true; 
            } catch (error) {
                console.error("Erro ao deletar agendamento no servidor:", error);
                alert("Erro ao tentar cancelar agendamento! Consulte o console.");
                return false;
            }
            */
            
            console.log("SIMULANDO: Servidor aceitou o cancelamento.");
            return true;
        };


        // ====================================================================
        // 1. COMPONENTE LOGIN DONO (SEM MUDANÇAS)
        // ====================================================================
        const LoginDono = ({ onLoginSuccess, onCancel }) => {
            const [username, setUsername] = React.useState('');
            const [password, setPassword] = React.useState('');
            const [error, setError] = React.useState('');

            const handleSubmit = (e) => {
                e.preventDefault();
                const USER_CORRETO = "Dono";
                const SENHA_CORRETA = "123";

                if (username === USER_CORRETO && password === SENHA_CORRETA) {
                    setError('');
                    onLoginSuccess();
                } else {
                    setError('Usuário ou senha incorretos.');
                }
            };

            return (
                <div className="login-form">
                    <h3>Acesso Restrito - Dono/Profissional</h3>
                    <p style={{textAlign: 'center', fontSize: '0.8em'}}>Usuário de Teste: Dono, Senha: 123</p>
                    <form onSubmit={handleSubmit}>
                        {error && <p className="error-message">{error}</p>}
                        <label>
                            Usuário:
                            <input type="text" value={username} onChange={(e) => setUsername(e.target.value)} required />
                        </label>
                        <label>
                            Senha:
                            <input type="password" value={password} onChange={(e) => setPassword(e.target.value)} required />
                        </label>
                        <div className="login-actions">
                            <button type="submit">Entrar</button>
                            <button type="button" onClick={onCancel}>Voltar</button>
                        </div>
                    </form>
                </div>
            );
        };

        // ====================================================================
        // 2. COMPONENTE AGENDAMENTO CLIENTE (SEM MUDANÇAS)
        // ====================================================================
        const AgendamentoCliente = ({ dataSelecionada, horarioSelecionado, onAgendar }) => {
            const [nome, setNome] = React.useState('');
            const [servico, setServico] = React.useState(SERVICOS[0].nome);
            const [telefone, setTelefone] = React.useState('');

            const handleSubmit = (e) => {
                e.preventDefault();
                if (nome && horarioSelecionado) {
                    const id = `${dataSelecionada}-${horarioSelecionado}-${Date.now()}`;
                    onAgendar({ id, nome, data: dataSelecionada, horario: horarioSelecionado, servico, telefone });
                    
                    // Limpa o formulário APÓS o agendamento ser processado (no onAgendar)
                    setNome('');
                    setServico(SERVICOS[0].nome);
                    setTelefone('');
                }
            };

            return (
                <form onSubmit={handleSubmit} className="form-agendamento">
                    <h3>Agendar para: {dataSelecionada} às {horarioSelecionado}</h3>
                    <label>
                        Nome:
                        <input type="text" value={nome} onChange={(e) => setNome(e.target.value)} required />
                    </label>
                    <label>
                        Telefone:
                        <input type="tel" value={telefone} onChange={(e) => setTelefone(e.target.value)} />
                    </label>
                    <label>
                        Serviço:
                        <select value={servico} onChange={(e) => setServico(e.target.value)} required>
                            {SERVICOS.map(s => <option key={s.nome} value={s.nome}>{s.nome}</option>)}
                        </select>
                    </label>
                    <button type="submit">Confirmar Agendamento</button>
                </form>
            );
        };

        // ====================================================================
        // 3. COMPONENTE AGENDA (Com integração de "Backend")
        // ====================================================================
        const Agenda = ({ perfil }) => {
            // Estado principal, agora iniciado como vazio (será preenchido pelo fetch)
            const [todosAgendamentos, setTodosAgendamentos] = React.useState({});
            const [dataSelecionada, setDataSelecionada] = React.useState(DATA_INICIAL);
            const [horarioSelecionado, setHorarioSelecionado] = React.useState(null);
            const [isLoading, setIsLoading] = React.useState(true);

            // Agendamentos apenas para o dia selecionado
            const agendamentosDoDia = todosAgendamentos[dataSelecionada] || [];

            // ⭐️ useEffect para CARREGAR DADOS NA INICIALIZAÇÃO
            React.useEffect(() => {
                const loadData = async () => {
                    setIsLoading(true);
                    // Passamos o setter do estado para a função assíncrona
                    await fetchAgendamentos(setTodosAgendamentos);
                    setIsLoading(false);
                };
                loadData();
            }, []); // Array vazio garante que rode apenas uma vez

            const isOcupado = (horario) => {
                return agendamentosDoDia.some(a => a.horario === horario);
            };

            // Função para Cancelar Agendamento (Usado pelo Dono)
            const handleCancelar = async (agendamentoId) => {
                if (window.confirm("Tem certeza que deseja CANCELAR este agendamento?")) {
                    const success = await deleteAgendamentoFromServer(agendamentoId); // ⭐️ Chama a API
                    
                    if (success) {
                         // Se o servidor aceitou, atualizamos o estado local
                        setTodosAgendamentos(prevTodos => {
                            const updatedDayAppointments = prevTodos[dataSelecionada].filter(
                                a => a.id !== agendamentoId
                            );
                            return {
                                ...prevTodos,
                                [dataSelecionada]: updatedDayAppointments
                            };
                        });
                        alert("Agendamento cancelado com sucesso!");
                    }
                }
            };
            
            const handleHorarioClick = (horario) => {
                const ocupado = isOcupado(horario);
                setHorarioSelecionado(null);

                if (perfil === 'cliente') {
                    if (!ocupado) {
                        setHorarioSelecionado(horario);
                    } else {
                        alert('Este horário já está ocupado. Por favor, selecione outro.');
                    }
                } else if (perfil === 'dono') {
                    const agendamento = agendamentosDoDia.find(a => a.horario === horario);
                    
                    if (agendamento) {
                        const confirmCancel = window.confirm(`DETALHES DO AGENDAMENTO:\nDia: ${agendamento.data}\nHorário: ${agendamento.horario}\nCliente: ${agendamento.nome}\nServiço: ${agendamento.servico}\nTel: ${agendamento.telefone}\n\nDeseja CANCELAR este agendamento?`);
                        
                        if (confirmCancel) {
                            handleCancelar(agendamento.id);
                        }
                    } else {
                        alert(`Horário ${horario} do dia ${dataSelecionada} está livre.`);
                    }
                }
            };

            const handleAgendar = async (novoAgendamento) => {
                if (isOcupado(novoAgendamento.horario)) {
                    alert('Erro: Horário ocupado.');
                    return;
                }
                
                // ⭐️ Envia o agendamento para o "servidor"
                const savedAgendamento = await sendAgendamentoToServer(novoAgendamento);

                if (savedAgendamento) {
                    // Atualiza o estado local apenas se o servidor aceitou
                    setTodosAgendamentos(prevTodos => {
                        const currentDayAppointments = prevTodos[novoAgendamento.data] || [];

                        return {
                            ...prevTodos,
                            [novoAgendamento.data]: [...currentDayAppointments, savedAgendamento]
                        };
                    });
                    
                    setHorarioSelecionado(null);
                }
            };

            if (isLoading) {
                return <div className="loading-message">Carregando dados... (Aguarde alguns segundos)</div>;
            }

            return (
                <div className={perfil === 'dono' ? 'agenda-dono' : ''}>
                    <h2>Agenda de Horários ({perfil === 'dono' ? 'Dono' : 'Cliente'})</h2>
                    
                    {/* Seletor de Data */}
                    <div className="seletor-data">
                        <label>
                            Escolher Dia:
                            <select 
                                value={dataSelecionada} 
                                onChange={(e) => { 
                                    setDataSelecionada(e.target.value); 
                                    setHorarioSelecionado(null);
                                }}
                            >
                                {DIAS_DISPONIVEIS.map(dia => (
                                    <option key={dia.value} value={dia.value}>{dia.label}</option>
                                ))}
                            </select>
                        </label>
                        <p className="data-atual">Dia Selecionado: <strong>{dataSelecionada}</strong></p>
                    </div>

                    <div className="agenda-container">
                        {HORARIOS.map((horario) => {
                            const ocupado = isOcupado(horario);
                            const classe = ocupado ? 'ocupado' : 'livre';

                            return (
                                <div
                                    key={horario}
                                    className={`horario ${classe}`}
                                    onClick={() => handleHorarioClick(horario)}
                                >
                                    {horario}
                                    <br />
                                    <span style={{ fontSize: '0.8em' }}>{ocupado ? 'Ocupado' : 'Livre'}</span>
                                </div>
                            );
                        })}
                    </div>

                    {/* Formulário visível apenas para o cliente e se um horário livre for selecionado */}
                    {perfil === 'cliente' && horarioSelecionado && !isOcupado(horarioSelecionado) && (
                        <AgendamentoCliente 
                            dataSelecionada={dataSelecionada}
                            horarioSelecionado={horarioSelecionado} 
                            onAgendar={handleAgendar} 
                        />
                    )}
                </div>
            );
        };

        // ====================================================================
        // 4. COMPONENTE APP (Gerencia o estado do perfil e login)
        // ====================================================================
        const App = () => {
            const [perfil, setPerfil] = React.useState('cliente'); 

            const handleSetPerfil = (novoPerfil) => {
                if (novoPerfil === 'dono') {
                    setPerfil('login_dono');
                } else if (novoPerfil === 'cliente') {
                    setPerfil('cliente');
                } else if (novoPerfil === 'dono_logado') {
                    setPerfil('dono_logado');
                }
            };

            const perfilAgenda = perfil === 'dono_logado' ? 'dono' : 'cliente';

            let content;
            if (perfil === 'login_dono') {
                content = (
                    <LoginDono 
                        onLoginSuccess={() => handleSetPerfil('dono_logado')} 
                        onCancel={() => handleSetPerfil('cliente')} 
                    />
                );
            } else {
                content = <Agenda perfil={perfilAgenda} />;
            }

            return (
                <div className="App">
                    <header>
                        <img src="logo-salao.png" alt="Logotipo do Salão de Beleza" className="site-logo" />
                        <h1>Sistema de Agendamento de Beleza Multi-Dias</h1>
                        <p style={{fontSize: '0.8em', color: '#dc3545', fontWeight: 'bold'}}>⚠️ Simulação de Servidor: Agendamentos não serão salvos após recarregar!</p>
                    </header>
                    
                    <div className="perfil-botoes">
                        <button 
                            className={`cliente ${perfil === 'cliente' ? 'ativo' : ''}`}
                            onClick={() => handleSetPerfil('cliente')}
                        >
                            Visualização Cliente
                        </button>
                        <button 
                            className={`dono ${perfil === 'dono_logado' ? 'ativo' : ''}`}
                            onClick={() => handleSetPerfil('dono')}
                            disabled={perfil === 'dono_logado'}
                        >
                            Acesso Dono
                        </button>
                        
                        {perfil === 'dono_logado' && (
                            <button 
                                className="dono"
                                onClick={() => handleSetPerfil('cliente')}
                                style={{marginLeft: '10px', backgroundColor: '#dc3545'}}
                            >
                                Sair (Dono Logado)
                            </button>
                        )}
                    </div>
                    
                    {content}
                </div>
            );
        };

        // ====================================================================
        // 5. RENDERIZAÇÃO FINAL
        // ====================================================================
        const root = ReactDOM.createRoot(document.getElementById('root'));
        root.render(<App />);

    </script>
</body>
</html>